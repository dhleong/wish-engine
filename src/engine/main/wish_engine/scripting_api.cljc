(ns wish-engine.scripting-api
  "Public scripting API"
  (:require [wish-engine.runtime.api :refer-macros [defn-api]]))


(def exported-fns {})

(def ^:dynamic *engine-state* nil)

; ======= utils ===========================================

(defn throw-msg [& message]
  (throw #?(:cljs (js/Error. (apply str message))
            :clj (Exception. (apply str message)))))

(defn throw-arg [fn-name arg]
  (throw-msg "Invalid argument to " fn-name ": " arg))

(defn flatten-lists
  "Call on a varargs list to support both the usual varargs invocation and
   passing in sequences, such as might be generated by `(map)` or a list
   comprehension"
  [fn-name valid? args]
  (mapcat (fn [f]
            (cond
              (valid? f) [f]
              (seq? f) f
              :else (throw-arg fn-name f)))
          args))

(def ^:private key-or-map? #(or (keyword? %)
                                (map? %)))


; ======= Validation ======================================

(defn validate-feature-map [m]
  (letfn [(throw-reason [& args]
            (throw-msg "Invalid feature ("
                       (apply str args)
                       "):\n"
                       m))]
    (when-not (:id m)
      (throw-reason "missing :id"))

    ; return m if valid
    m))


; ======= Util API ========================================

(defn-api has?
  "Alias for (some) that can handle sets in production"
  [vals-set coll]
  (some
    (fn [item]
      (contains? vals-set item))
    coll))

(defn-api ordinal [n]
  (str n
       (if (<= 11 n 19)
         "th"
         (let [ones (rem n 10)]
           (case ones
             1 "st"
             2 "nd"
             3 "rd"
             "th")))))


; ======= top-level forms =================================

(defn-api declare-features [& features]
  (when-not *engine-state*
    (throw-msg "declare-features must be called at the top level"))

  (swap! *engine-state*
         update
         :features
         merge

         (->> features

              (flatten-lists "declare-features" map?)

              (reduce (fn [m f]
                        (assoc m (:id f) f))
                      {}))))


; ======= Entity-modifying forms ==========================

(defn-api provide-feature [state feature]
  (when *engine-state*
    (throw-msg "provide-feature(s) must not be called at the top level. Try `declare-features`"))

  (let [id (cond
             (map? feature) (:id feature)
             (keyword? feature) feature
             :else (throw-msg "Invalid feature arg: " feature))

        ; declare the feature on the entity state, if a map
        state (if (map? feature)
                (assoc-in state
                          [:declared-features id]
                          (validate-feature-map feature))
                state)]

    (update state :feature-set (fn [existing]
                                 (if (set? existing)
                                   (conj existing id)
                                   #{id})))))

(defn-api provide-features [state & features]
  (loop [state state
         features (flatten-lists
                    "provide-features"
                    key-or-map?
                    features)]
    (if-let [f (first features)]
      (recur (provide-feature state f)
             (rest features))
      state)))
